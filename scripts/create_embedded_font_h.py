#!/usr/bin/env python3
"""Generate C header embedding a TTF font as a byte array.
Usage:
  python embed_ttf.py path/to/font.ttf minibae/gui/embedded_font.h [--symbol-name NAME]
Environment/flags:
  The output header defines:
    extern const unsigned char embedded_font_data[];
    extern const unsigned int embedded_font_size;
  And (unless --no-guard) include guard GUI_EMBEDDED_FONT_H.
After generating the header, build with -DEMBED_TTF_FONT to enable usage.
"""
import sys, os, textwrap

def main():
    if len(sys.argv) < 3:
        print("Usage: embed_ttf.py <font.ttf> <out_header> [--symbol-name <name>]")
        return 1
    font_path = sys.argv[1]
    out_path = sys.argv[2]
    sym_name = "embedded_font"  # base name
    if "--symbol-name" in sys.argv:
        idx = sys.argv.index("--symbol-name")
        if idx+1 < len(sys.argv):
            sym_name = sys.argv[idx+1]
    if not os.path.isfile(font_path):
        print(f"Error: font file not found: {font_path}")
        return 1
    data = open(font_path, 'rb').read()
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, 'w', newline='\n') as f:
        f.write("// Auto-generated by embed_ttf.py. DO NOT EDIT.\n")
        f.write("#ifndef GUI_EMBEDDED_FONT_H\n#define GUI_EMBEDDED_FONT_H\n\n")
        f.write("#include <stddef.h>\n#include <stdint.h>\n\n")
        f.write(f"static const unsigned char {sym_name}_data[] = {{\n")
        # format bytes 16 per line
        for i in range(0, len(data), 16):
            chunk = data[i:i+16]
            f.write("    " + ", ".join(f"0x{b:02X}" for b in chunk))
            f.write(",\n")
        f.write("};\n")
        f.write(f"static const unsigned int {sym_name}_size = {len(data)};\n")
        # provide the expected generic symbols
        f.write(f"#define embedded_font_data {sym_name}_data\n")
        f.write(f"#define embedded_font_size {sym_name}_size\n")
        f.write("\n#endif // GUI_EMBEDDED_FONT_H\n")
        # Perform a stat on the output file to get its size
    stat_info = os.stat(out_path)
    print(f"Wrote {out_path} ({stat_info.st_size} bytes) as C array ({len(data)} bytes raw)")
    return 0

if __name__ == '__main__':
    raise SystemExit(main())
