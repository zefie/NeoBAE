#!/usr/bin/env python3
"""Generate C header embedding a binary patch bank as a byte array.
Usage:
  python create_embedded_patches_h.py <patch.bin> <out_header> [--symbol-name NAME]

This produces a header that defines:
  static const unsigned char BAE_PATCHES[] = { ... };
  static const unsigned long BAE_PATCHES_size = <size>;
  static unsigned char* BAE_PATCHES_end = (unsigned char*)BAE_PATCHES + BAE_PATCHES_size;

The default symbol name is BAE_PATCHES to match existing code.
"""
import sys, os

def main():
    if len(sys.argv) < 3:
        print("Usage: create_embedded_patches_h.py <patch.bin> <out_header> [--symbol-name NAME]")
        return 1
    in_path = sys.argv[1]
    out_path = sys.argv[2]
    sym = "BAE_PATCHES"
    if "--symbol-name" in sys.argv:
        idx = sys.argv.index("--symbol-name")
        if idx+1 < len(sys.argv):
            sym = sys.argv[idx+1]
    if not os.path.isfile(in_path):
        print(f"Error: input file not found: {in_path}")
        return 1
    data = open(in_path, 'rb').read()
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, 'w', newline='\n') as f:
        f.write("// Auto-generated by create_embedded_patches_h.py. DO NOT EDIT.\n")
        f.write("#ifndef BAE_PATCHES_EMBED_H\n#define BAE_PATCHES_EMBED_H\n\n")
        f.write("#include <stddef.h>\n#include <stdint.h>\n\n")
        # Generate non-static definitions to match existing BAEPatches.c / .h symbols
        f.write(f"unsigned char {sym}[] = {{\n")
        for i in range(0, len(data), 16):
            chunk = data[i:i+16]
            f.write("    " + ", ".join(f"0x{b:02X}" for b in chunk))
            f.write(",\n")
        f.write("};\n\n")
        # Emit a macro for the size (constant) so pointer initializers can use a
        # compile-time constant. Also provide the runtime variable for code that
        # expects an exported unsigned long symbol.
        f.write(f"#define BAE_PATCHES_SIZE {len(data)}UL\n\n")
        f.write(f"unsigned long {sym}_size = BAE_PATCHES_SIZE;\n")
        f.write(f"unsigned char* {sym}_end = {sym} + BAE_PATCHES_SIZE;\n\n")
        # Provide compatibility macros for older code expecting names without trailing _data
        f.write("#define BAE_PATCHES_ARRAY " + f"{sym}\n\n")
        f.write("#endif // BAE_PATCHES_EMBED_H\n")
    st = os.stat(out_path)
    print(f"Wrote {out_path} ({st.st_size} bytes) embedding {len(data)} bytes")
    return 0

if __name__ == '__main__':
    raise SystemExit(main())
