BUILD_DIR	:= build/
TEST_OUT_DIR	:= tests/
TARGET_OUT	:= bin/
BAE_FLAGS	:=
ifneq ($(WASM),1)
	ifneq ($(NOAUTO),1)
		MP3_DEC := 1
		MP3_ENC := 1
		FLAC_DEC := 1
		FLAC_ENC := 1
		KARAOKE := 1
		PLAYLIST :=1
	endif
endif

# GUI Font
EMBED_TTF_FONT := src/thirdparty/fonts/HelveticaNeue.ttf

# Built-in Patches
EMBED_PATCH_FILE := src/banks/patches111/patches111.hsb

ifneq ($(filter 1,$(VERBOSE) $(V)),)
	SILENT :=
else
	SILENT := @
endif

# Begin Allow Overrides
ifeq ($(TARGET_LIB),)
	TARGET_LIB	:= libminiBAE
endif

ifeq ($(TARGET_BIN),)
	ifneq ($(BUILD_GUI),) 
		TARGET_BIN	:= minibae_gui
	else
		TARGET_BIN	:= playbae
	endif
endif

ifeq ($(TEST_BIN_PREFIX),)
	TEST_BIN	:= $(TARGET_OUT)$(TARGET_BIN)
else
	TEST_BIN	:= $(TEST_BIN_PREFIX)$(TARGET_OUT)$(TARGET_BIN)
endif
# End Allow Overrides

vpath	%.c src/BAE_Source/Common src/BAE_Source/Platform
vpath	%.c src/banks/patches111
vpath	%.c src/BAE_MPEG_Source_II

ifeq ($(BUILD_GUI),1) 
	vpath	%.c src/gui
else
	vpath	%.c src/playbae
endif


INC_PATH	:= -Isrc/BAE_Source/Common
INC_PATH	+= -Isrc/BAE_Source/Platform
INC_PATH	+= -Isrc/thirdparty/config

ifneq ($(filter 1,$(MP3_ENC) $(MP3_DEC)),) 
	vpath	%.cpp src/BAE_MPEG_Source_II
	INC_PATH  += -Isrc/BAE_MPEG_Source_II
endif

# Ensure the legacy MPG API implementation is built when MP3 encoder or
# decoder support is enabled. XMPEG_BAE_API.c implements MPG_* and
# X* MPEG helper functions needed across the codebase.
ifeq ($(filter 1,$(MP3_ENC) $(MP3_DEC)),1)
	SRC += XMPEG_BAE_API.c
endif

ifeq ($(BAE_BUILT_IN_PATCHES),1)
INC_PATH	+= -Isrc/banks/patches111
endif

ifeq ($(MP3_DEC),1)
INC_PATH	+= -Isrc/thirdparty/minimp3
endif

ifeq ($(ENABLE_MIDI_HW),1)
INC_PATH	+= -Isrc/thirdparty/rtmidi
	vpath	%.cpp src/thirdparty/rtmidi
	vpath	%.c src/thirdparty/rtmidi
endif

ifneq ($(filter 1,$(FLAC_ENC) $(FLAC_DEC)),) 
	vpath	%.c src/thirdparty/flac/src/libFLAC
	INC_PATH	+= -Isrc/thirdparty/flac/include -Isrc/thirdparty/flac/src/libFLAC/include
	# Build libFLAC sources into the binary/static library instead of
	# expecting a DLL import. Ensure headers don't declare functions as
	# __declspec(dllimport).
	BAE_FLAGS += -DFLAC__NO_DLL -DHAVE_CONFIG_H=1
	BAE_FLAGS += -DHAVE_STDINT_H=1 -DHAVE_INTTYPES_H=1 -DFLAC__HAS_OGG=0 -DSIZE_T_MAX=SIZE_MAX
endif

# default to ANSI
ifeq ($(BAE_API),)
	BAE_API		:= Ansi
endif

## Begin Easy API -> X_PLATFORM
# Supported APIs
ifeq ($(BAE_API),Ansi)
	BAE_FLAGS += 	-DX_PLATFORM=X_ANSI
	SRC       :=	BAE_API_$(BAE_API).c
endif
ifeq ($(BAE_API),WinOS)
	BAE_FLAGS += 	-DX_PLATFORM=X_WIN95
	SRC       :=	BAE_API_$(BAE_API).c \
			BAE_API_$(BAE_API)_Capture.c \
			BAE_API_$(BAE_API)_Thread.c
endif

# zefie has not tested these APIs
ifeq ($(BAE_API),MacOSX)
	BAE_FLAGS += 	-DX_PLATFORM=X_MACINTOSH
	SRC       :=	BAE_API_$(BAE_API).c
endif
ifeq ($(BAE_API),Android)
	BAE_FLAGS += 	-DX_PLATFORM=X_ANDROID
	SRC       :=	BAE_API_$(BAE_API).c
endif
ifeq ($(BAE_API),IOS)
	BAE_FLAGS += 	-DX_PLATFORM=X_IOS
	SRC       :=	BAE_API_$(BAE_API).c
endif
ifeq ($(BAE_API),SDL2)
	BAE_FLAGS += 	-DX_PLATFORM=X_SDL2
	SRC       :=	BAE_API_$(BAE_API).c
endif
## End Easy API -> X_PLATFORM
### End configure BAE API

# Debug
ifeq ($(DEBUG),1)
	BAE_FLAGS +=    -D_DEBUG=1
endif


# Primary libMiniBAE sources
SRC		+=	DriverTools.c \
			GenAudioStreams.c \
			GenCache.c \
			GenChorus.c \
			GenFiltersReverbU3232.c \
			GenInterp2ReverbU3232.c \
			GenOutput.c \
			GenPatch.c \
			GenReverb.c \
			GenReverbNew.c \
			GenSample.c \
			GenSeq.c \
			GenSeqTools.c \
			GenSetup.c \
			GenSong.c \
			GenSoundFiles.c \
			GenSynth.c \
			GenSynthFiltersSimple.c \
			GenSynthFiltersU3232.c \
			GenSynthInterp2Simple.c \
			GenSynthInterp2U3232.c \
			MiniBAE.c \
			NewNewLZSS.c \
			SampleTools.c \
			X_API.c \
			X_Decompress.c \
			X_IMA.c \
			g711.c \
			g721.c \
			g723_24.c \
			g723_40.c \
			g72x.c \
			sha1mini.c

ifeq ($(MP3_DEC),1)
	# Enable minimp3 wrapper for MPG_* API (decoder only)
	BAE_FLAGS += -DUSE_MINIMP3_WRAPPER=1 -DUSE_MPEG_DECODER=1
	SRC += XMPEG_minimp3_wrapper.c
endif

# Include XMPEGFilesSun.c when either encoder or decoder is enabled
ifneq ($(filter 1,$(MP3_ENC) $(MP3_DEC)),) 
	SRC += XMPEGFilesSun.c
endif

# Optional MP3 encoder integration
# Enable with make MP3_ENC=1 (or set in environment)
# Default to using LAME (MIT-like/GPL licensed) instead of the Helix hmp3
# to avoid problematic licensing. This compiles the bundled LAME sources
# and provides an adapter that implements the legacy MPG_Encode* API.
ifeq ($(MP3_ENC),1)
	# Let LAME detect standard headers correctly on our build host
	BAE_FLAGS += -DUSE_MPEG_ENCODER=1 -DUSE_LAME_ENCODER=1 -DIEEE_FLOAT -DSTDC_HEADERS=1 -DHAVE_STDINT_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_CONFIG_H=1
	# Add LAME include path so adapter can find "lame.h"
	INC_PATH += -Isrc/thirdparty/lame-3.100-slim/include
	# Also make top-level LAME dir visible so <config.h> (provided below) is found
	INC_PATH += -Isrc/thirdparty/lame-3.100-slim
	INC_PATH += -Isrc/thirdparty/lame-3.100-slim/libmp3lame
	# Let the build find LAME source files (libmp3lame and mpglib)
	vpath	%.c src/thirdparty/lame-3.100-slim/libmp3lame
	vpath	%.c src/thirdparty/lame-3.100-slim/mpglib
	# Add all libmp3lame and mpglib C sources and the LAME adapter.
	# Using wildcard keeps this list maintainable when LAME sources change.
	ifeq ($(shell [ -d src/thirdparty/lame-3.100-slim/libmp3lame ] && echo yes),yes)
		SRC += bitstream.c \
			newmdct.c \
			tables.c \
			encoder.c \
			presets.c \
			takehiro.c \
			fft.c \
			psymodel.c \
			util.c \
			gain_analysis.c \
			quantize.c \
			vbrquantize.c \
			id3tag.c \
			quantize_pvt.c \
			VbrTag.c \
			lame.c \
			reservoir.c \
			version.c \
			mpglib_interface.c \
			set_get.c \
			common.c \
			decode_i386.c \
			layer1.c \
			layer3.c \
			dct64_i386.c \
			interface.c \
			layer2.c \
			tabinit.c
	endif
	SRC += XMPEG_lame_encoder.cpp
endif

# Add FLAC decoder source files
ifeq ($(FLAC_DEC),1)
	BAE_FLAGS += -DUSE_FLAC_DECODER=1
	SRC += stream_decoder.c bitreader.c bitmath.c bitwriter.c cpu.c crc.c fixed.c format.c lpc.c md5.c memory.c metadata_iterators.c metadata_object.c stream_encoder_framing.c window.c
endif

# Add FLAC encoder source files  
ifeq ($(FLAC_ENC),1)
	BAE_FLAGS += -DUSE_FLAC_ENCODER=1
	# stream_encoder.c is the main encoding engine, and it depends on decoder for verification
	SRC += stream_encoder.c
	ifneq ($(FLAC_DEC),1)
		# Add required FLAC files for encoding, including decoder support for verification
		SRC += stream_decoder.c bitreader.c bitmath.c bitwriter.c cpu.c crc.c fixed.c format.c lpc.c md5.c memory.c metadata_iterators.c metadata_object.c stream_encoder_framing.c window.c
	endif
endif


# playbae = libMiniBAE srcs + playbae.c
ifeq ($(BUILD_GUI),1)
	BAE_FLAGS += -DOUTPUT_TO_LOGFILE=1
	SRC_BIN	:= $(SRC) gui_logging.c gui_theme.c gui_widgets.c gui_text.c gui_midi_vkbd.c gui_karaoke.c gui_export.c gui_dialogs.c gui_bae.c gui_settings.c gui_main.c
else
	SRC_BIN	:= $(SRC) playbae.c
endif

ifeq ($(ENABLE_MIDI_HW),1)
	ifneq ($(BUILD_GUI),)
		# RtMidi (C wrapper) - provide real-time MIDI input for GUI
		BAE_FLAGS += -DSUPPORT_MIDI_HW=1
		SRC_BIN +=  gui_midi_hw.c gui_midi_hw_input.c gui_midi_hw_output.c rtmidi_c.cpp RtMidi.cpp
	endif
endif

ifeq ($(PLAYLIST),1)
	ifneq ($(BUILD_GUI),)
		BAE_FLAGS += -DSUPPORT_PLAYLIST=1
		SRC_BIN +=  gui_playlist.c
	endif
endif


ifeq ($(LOGFILE),1)
	BAE_FLAGS += -DOUTPUT_TO_LOGFILE=1
endif

ifeq ($(WINDOWS),1)
	ifneq ($(filter 1,$(FLAC_DEC) $(FLAC_ENC)),)
		vpath	%.c src/thirdparty/flac/src/share/win_utf8_io
		INC_PATH += -Isrc/thirdparty/flac/src/share/win_utf8_io
		BAE_FLAGS += -DFLAC__NO_DLL
		SRC += win_utf8_io.c
		SRC_BIN += win_utf8_io.c
	endif
endif

ifeq ($(KARAOKE),1)
	BAE_FLAGS += -DSUPPORT_KARAOKE=1
endif


OBJ_DIR 	:= $(BUILD_DIR)obj/
OBJ 		:= $(addprefix $(OBJ_DIR),$(addsuffix .o,$(basename ${SRC})))
OBJ_BIN 	:= $(addprefix $(OBJ_DIR),$(addsuffix .o,$(basename ${SRC_BIN})))

ifeq ($(BUILD_GUI),1)

BAE_FLAGS += -D_ZEFI_GUI=1

# If EMBED_TTF_FONT specified, generate embedded_font.h and define EMBED_TTF_FONT
ifdef EMBED_TTF_FONT
BAE_FLAGS += -DEMBED_TTF_FONT -I$(OBJ_DIR)

EMBED_FONT_HEADER := $(OBJ_DIR)embedded_font.h
$(EMBED_FONT_HEADER): $(EMBED_TTF_FONT) ../scripts/create_embedded_font_h.py
	@echo @embed $<
	@mkdir -p $(dir $(EMBED_FONT_HEADER))
	@python3 ../scripts/create_embedded_font_h.py $(EMBED_TTF_FONT) $(EMBED_FONT_HEADER)

$(OBJ_DIR)gui_main.o: $(EMBED_FONT_HEADER)
endif # EMBED_FONT_HEADER

endif # BUILD_GUI

# If EMBED_PATCH_FILE specified, generate BAEPatches.h that embeds the binary bank
ifdef EMBED_PATCH_FILE
BAE_FLAGS += -D_BUILT_IN_PATCHES=1 -I$(OBJ_DIR)

EMBED_PATCH_HEADER := $(OBJ_DIR)BAEPatches.h
$(EMBED_PATCH_HEADER): $(EMBED_PATCH_FILE) ../scripts/create_embedded_patches_h.py
	@echo @embed $<
	@mkdir -p $(dir $(EMBED_PATCH_HEADER))
	@python3 ../scripts/create_embedded_patches_h.py $(EMBED_PATCH_FILE) $(EMBED_PATCH_HEADER)
$(OBJ_DIR)MiniBAE.o: $(EMBED_PATCH_HEADER)

# Ensure generated header is available to build when EMBED_PATCH_FILE is used
endif # EMBED_PATCH_FILE

#### End Makefile.common
